[video @nothings ~obbg title="Open Block Building Game Development #7" platform=youtube id=KUbke-XZZQg annotator=@Miblo]
[1:07][Recap and set the stage for the day]
[2:26][On using Wang tiles to [:"procedural generation" generate] trees on chunk corners and edges]
[4:05][Run the :game and see how the trees are spaced]
[5:05][Add a type to the tree_location struct in order to use different textures for trees on corners and edges][:"procedural generation"]
[6:56][@cubercaleb][Is [@nothings2 Sean] standing?]
[8:32][Run the :game and see the newly differentiated trees]
[8:55][Make generate_trees_for_corner() check for collisions][:"procedural generation"]
[9:48][Run the :game and see our newly spaced trees in corners]
[10:57][Introduce collides_raw() that takes a raw array][:"procedural generation"]
[12:03][@d7samurai][Should we dub those frontpage trolls "twitches"?]
[12:25][Make generate_trees_for_chunk() [:"procedural generation" generate] the inner trees]
[15:32][Run the :game and see some pretty huge gaps]
[15:39][Increase the amount of trees and apparently place one out of range][:"procedural generation"]
[17:40][Make generate_chunk() and generate_trees_for_chunk() obey the MAX_TREES_PER_CHUNK][:"procedural generation"]
[19:15][@kelimion][@nothings2, Is there something like Valgrind for windows, which would track down :memory accesses like this?]
[19:22][Run the :game and see the trees]
[20:22][Make generate_chunk() draw a block of sand at the chunk corners]
[21:18][Run the :game and see the chunk boundaries]
[22:17][Make generate_trees_for_corner() iterate more times][:"procedural generation"]
[22:37][Run the :game and only ever see at most two trees at the corners]
[23:04][@kelimion][@nothings2, if you want to burn some cycles, you could put the expected border around the trees as a debug method. If they overlap instead of abut, it's messed up]
[23:52][Revert generate_trees_for_corner() to iterate twice and make generate_trees_for_chunk() use flat_noise32_weak()][:"procedural generation"]
[26:21][Run the :game and see that it is not exactly the same as it was]
[26:31][Make generate_trees_for_chunk() put the range checking back into the global coordinate space][:"procedural generation"]
[26:52][Run the :game and see gaps in the trees, before trying flat_noise32_strong() and then making generate_trees_for_chunk() iterate fewer times and draw all the trees with the same texture][:"procedural generation"]
[28:47][Run the :game to see our new tree layout before committing it]
[30:22][Consider how to make the leaves look less terrible][:"procedural generation"]
[32:43][@kelimion][@nothings2, is 3D perlin more expensive than stretching 2D noise into planes? (0..x/z, 0..y/z)?]
[35:07][@kelimion][@nothings2, mapping (x,y,z) into (sqrt(x/z), sqrt(y/z), so that the z layers sample x/z by y/z parts of the 0...1,0...1 plane]
[35:56][Double the TREE_MIN_SPACING, run the :game and see that the :"procedural generation" is overtly following the edges and corners]
[38:20][Make generate_chunk() draw leaves in a circle][:"procedural generation"]
[40:13][Introduce tree_shape_function()][:"procedural generation"]
[43:15][Introduce build_disk()][:"procedural generation"]
[46:05][Run the :game and see it draw nothing]
[46:29][Make generate_chunk add ht when making the leaves][:"procedural generation"]
[46:44][Run the :game and see the giant trees that are totally wrong]
[48:07][Make build_disk() test the radius in order draw them circular][:"procedural generation"]
[49:00][Make generate_chunk() draw the trees much taller][:"procedural generation"]
[49:46][Make tree_shape_function() correctly [:"procedural generation" generate] the bottom of the leaves]
[50:41][Make generate_chunk() only draw the trunk partway up][:"procedural generation"]
[52:04][Run the :game and see our trees]
[52:20][Make generate_chunk() fix the bias][:"procedural generation"]
[54:19][@kelimion][@nothings I was thinking that if you have an m by n by o cube, you could sample 2D perlin noise for each layer. Give or take: {for (z;;) for y (;;) for x (;;) x_y_z = perlin_noise(x, y, seed+z);  } So using a less expensive perlin2d more often, or is that as expensive as a perlin_3d?]
[54:45][Run the :game and spot a potential chunk boundary bug]
[55:29][Make generate_chunk() assert that dx and dy are between certain values][:"procedural generation"]
[56:42][Run the :game and hit those assertions]
[57:30][Make generate_chunk() cast the radius to int][:"procedural generation"]
[58:15][Run the :game and see the trees slope in different directions]
[58:31][Make generate_chunk() draw the chunk boundaries][:"procedural generation"]
[1:00:15][Run the :game and see how the trees are drawn relative to the chunk boundaries]
[1:01:16][Make generate_trees_for_chunk() plant the leaves higher up the trees][:"procedural generation"]
[1:01:48][Run the :game and walk through the trees]
[1:02:56][Hit a bug with the terrain not being generated high enough]
[1:03:44][Increase AVG_GROUND]
[1:04:08][Run the :game in the hopes that it'll be less likely to crash]
[1:04:37][Increase the view_distance and run the :game in release]
[1:06:02][End the stream here]
[/video]
