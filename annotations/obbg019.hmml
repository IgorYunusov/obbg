[video member=nothings twitch_username=nothings2 project=obbg title="Open Block Building Game Development #19" platform=youtube id=GwaP4yM-yj8 annotator=Miblo]
[1:25][Hello!]
[2:06][@connor_rentz][@nothings2 Did your setup change? Looks like you're in a different room]
[2:37][A few words on not talking very much]
[4:00][Understanding :Networking]
[5:18][Video linked by [@sssmcgrath Shawn McGrath]
    [ref
    site=YouTube
    page="Developer Update | Let's Talk Netcode | Overwatch"
    url=https://www.youtube.com/watch?v=vTH2ZPgYujQ]]
[5:35][@furroy][This is Fur from Sludge / Team Cthulhu days]
[7:38][The differing consistency of lock-step peer-to-peer vs client-server][:networking]
[11:00][A concrete explanation of why the client-server architecture is inconsistent][:networking]
[15:03][Accepting the players' inconsistent views of themselves in the world, and the "shooting around the corner" problem][:networking]
[16:52][Don't worry about the time delay][:networking]
[21:00][How this delay has consequences for :"game design"][:networking]
[23:13][Buffering the client packets and not worrying about consistency][:networking]
[29:15][@babeline][I'm 99% sure you want to implement a de-jitter buffer and extrapolate movements on lost frames still, though][:networking]
[29:53][@sssmcgrath][You don't need to de-jitter packets since you can DR everything on the client and server][:networking]
[30:51][@sssmcgrath][But you have to extrapolate if you don't have a packet, though, right?][:networking]
[32:32][@sssmcgrath][I don't technically "DR", I just step the simulation as though their input hasn't changed. Not sure if that qualifies][:networking]
[33:30][Delete the entire discussion of the server][:networking]
[34:34][Tweak the new explanation with more realistic values][:networking]
[36:40][Determine to do a fair job of :networking by default]
[39:22][@quikligames][Minecraft has several weird bugs with that stuff, but in general the block will reappear, but lots of sync bugs][:networking]
[39:49][A few words on client-side prediction potentially being preferable to lag-compensation, so long as we don't have disappearing platforms][:networking :"game design"]
[41:34][@popcorn0x90][So the client sends a bunch of the user's keys?]
[43:34][Considering clients' local clock-synchronisation][:networking]
[45:33][@nothings2][At first I was thinking "maybe in 50 years this will work when everyone's on a better net connection" but speed of light is maybe too fatal][:networking]
[46:17][Reduce the MAX_CLIENT_INPUT_HISTORY from 12 to 8 and consider the MAX_CLIENT_FRAME_NUMBER][:networking]
[49:39][Calculate the effect of buffering fewer inputs at a higher rate][:networking]
[53:19][@bl00drav3n][@nothings2, 108*30 = 3240]
[55:40][Increase NUM_INPUTS_PER_PACKET from 6 to 12, and comment the defined values][:networking]
[59:08][@sssmcgrath][That lag compensation (with looking back in time to see if a client could have shot another client) is basically not possible if you're physically simulating the reaction right? It'd only work on a boolean interaction, from what I can tell][:networking]
[1:01:11][@sssmcgrath][Rocket League doesn't feel super responsive, though. It could just be delaying your input by ~80ms or something on the client before predicting][:networking]
[1:07:55][@pragmascrypt][How would you sync time among clients so you can have some consistent frame index assuming you have slightly off-sync local clocks?][:networking]
[1:12:22][@sssmcgrath][My understanding was Overwatch only does the compensation for the four-frame input buffer][:networking]
[1:13:37][@babeline][It's adaptive, unlike Source, which is nice][:networking]
[1:16:37][@popcorn0x90][So let's say Player A shoots and kills Player B, but Player B is lagging and shot a shot. What would happen? Would the shot from Player B still be valid?][:networking]
[1:18:37][@babeline][Some games just throw out old inputs, like Source][:networking]
[1:19:01][Consider rewriting process_player_input() based on the new understanding][:networking]
[1:20:48][@christianrohr][It's really noticeable with, say, RPGs on Battlefield 4. The rockets sometimes just vanish into thin air if you die][:networking]
[1:22:54][@pragmascrypt][I'm always biased for programming]
[1:23:33][:Run the game, see if the client-side prediction is working and find that it is laggy][:networking]
[1:26:20][Suppress some of the output, :run the game again, find that the second client still feels sluggish at the beginning and investigate why][:networking]
[1:30:52][:Run the game and see that the server is not synchronised immediately][:networking]
[1:33:22][:Run the game, break into process_player_input() and find that we only sync at the halfway point][:networking]
[1:35:38][Ostensibly rewrite process_player_input() from scratch][:networking]
[1:44:50][:Run the game and see if it's synchronising right at the start][:networking]
[1:45:33][Re-enable the SDL_SetRelativeMouseMode][:"input handling"]
[1:47:31][:Run the game, consider special-casing the first input packet and find that it is correctly synchronising][:networking]
[1:49:17][Add done_initial_synchronization to the player_input_history struct and make process_player_input() operate on it][:networking]
[1:51:11][:Run the game to see if nothing broke, and find that there are some glitches in the synchronisation]
[1:55:08][Make client_net_tick() output "client net tick", :run the game and view that output]
[1:59:27][Determine to investigate these bursts at another time]
[2:00:00][Commit "fix sync of client input buffering; clarify server networking documentation"]
[2:01:15][Stop the stream]
[/video]
